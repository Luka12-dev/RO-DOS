/*
 * VESA VBE Video Driver for RO-DOS
 * Reads configuration passed from bootloader at 0x9000
 * Supports double buffering for flicker-free rendering
*/

#include <stdint.h>
#include <stdbool.h>
#include "portio.h"

/* VESA Info at 0x9000 (set by bootloader) */
#define VBE_INFO_ADDR 0x9000
typedef struct {
    uint32_t framebuffer;
    uint16_t width;
    uint16_t height;
    uint8_t bpp;
    uint8_t reserved;
} __attribute__((packed)) VbeBootInfo;

/* Driver state */
static VbeBootInfo *vbe_info = (VbeBootInfo*)VBE_INFO_ADDR;
static bool vbe_active = false;

/* Double buffering - backbuffer allocated in high memory */
static uint32_t *backbuffer = NULL;
static uint32_t backbuffer_size = 0;

/* External functions */
extern void c_puts(const char *s);
extern void c_putc(char c);
extern void set_mode_13h(void);
extern void setup_palette(void);
extern void *kmalloc(uint32_t size);

/* Simple 8x8 font for VBE mode */
static const uint8_t vbe_font8x8[128][8] = {
    [' '] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    ['!'] = {0x18,0x18,0x18,0x18,0x00,0x00,0x18,0x00},
    ['"'] = {0x6C,0x6C,0x24,0x00,0x00,0x00,0x00,0x00},
    ['\'']= {0x18,0x18,0x08,0x00,0x00,0x00,0x00,0x00},
    ['('] = {0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00},
    [')'] = {0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00},
    ['+'] = {0x00,0x18,0x18,0x7E,0x18,0x18,0x00,0x00},
    [','] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30},
    ['-'] = {0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00},
    ['.'] = {0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00},
    ['/'] = {0x06,0x0C,0x18,0x30,0x60,0xC0,0x80,0x00},
    [':'] = {0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00},
    ['='] = {0x00,0x00,0x7E,0x00,0x7E,0x00,0x00,0x00},
    ['?'] = {0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00},
    ['['] = {0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00},
    [']'] = {0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00},
    ['_'] = {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF},
    ['|'] = {0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18},
    /* Numbers */
    ['0'] = {0x3C,0x66,0x6E,0x76,0x66,0x66,0x3C,0x00},
    ['1'] = {0x18,0x38,0x18,0x18,0x18,0x18,0x7E,0x00},
    ['2'] = {0x3C,0x66,0x06,0x1C,0x30,0x60,0x7E,0x00},
    ['3'] = {0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00},
    ['4'] = {0x0C,0x1C,0x3C,0x6C,0x7E,0x0C,0x0C,0x00},
    ['5'] = {0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00},
    ['6'] = {0x3C,0x60,0x7C,0x66,0x66,0x66,0x3C,0x00},
    ['7'] = {0x7E,0x06,0x0C,0x18,0x30,0x30,0x30,0x00},
    ['8'] = {0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00},
    ['9'] = {0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00},
    /* Uppercase */
    ['A'] = {0x18,0x3C,0x66,0x7E,0x66,0x66,0x66,0x00},
    ['B'] = {0x7C,0x66,0x7C,0x66,0x66,0x66,0x7C,0x00},
    ['C'] = {0x3C,0x66,0x60,0x60,0x60,0x66,0x3C,0x00},
    ['D'] = {0x78,0x6C,0x66,0x66,0x66,0x6C,0x78,0x00},
    ['E'] = {0x7E,0x60,0x7C,0x60,0x60,0x60,0x7E,0x00},
    ['F'] = {0x7E,0x60,0x7C,0x60,0x60,0x60,0x60,0x00},
    ['G'] = {0x3C,0x66,0x60,0x6E,0x66,0x66,0x3C,0x00},
    ['H'] = {0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x00},
    ['I'] = {0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
    ['J'] = {0x1E,0x0C,0x0C,0x0C,0x0C,0x6C,0x38,0x00},
    ['K'] = {0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x00},
    ['L'] = {0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00},
    ['M'] = {0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x00},
    ['N'] = {0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x00},
    ['O'] = {0x3C,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    ['P'] = {0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x00},
    ['Q'] = {0x3C,0x66,0x66,0x66,0x6A,0x6C,0x36,0x00},
    ['R'] = {0x7C,0x66,0x66,0x7C,0x6C,0x66,0x66,0x00},
    ['S'] = {0x3C,0x66,0x60,0x3C,0x06,0x66,0x3C,0x00},
    ['T'] = {0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x00},
    ['U'] = {0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00},
    ['V'] = {0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00},
    ['W'] = {0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00},
    ['X'] = {0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00},
    ['Y'] = {0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x00},
    ['Z'] = {0x7E,0x06,0x0C,0x18,0x30,0x60,0x7E,0x00},
    /* Lowercase */
    ['a'] = {0x00,0x00,0x3C,0x06,0x3E,0x66,0x3E,0x00},
    ['b'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x7C,0x00},
    ['c'] = {0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00},
    ['d'] = {0x06,0x06,0x3E,0x66,0x66,0x66,0x3E,0x00},
    ['e'] = {0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00},
    ['f'] = {0x1C,0x30,0x7C,0x30,0x30,0x30,0x30,0x00},
    ['g'] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x3C},
    ['h'] = {0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x00},
    ['i'] = {0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00},
    ['j'] = {0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x6C,0x38},
    ['k'] = {0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x00},
    ['l'] = {0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00},
    ['m'] = {0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00},
    ['n'] = {0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00},
    ['o'] = {0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00},
    ['p'] = {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60},
    ['q'] = {0x00,0x00,0x3E,0x66,0x66,0x3E,0x06,0x06},
    ['r'] = {0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x00},
    ['s'] = {0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00},
    ['t'] = {0x30,0x30,0x7C,0x30,0x30,0x30,0x1C,0x00},
    ['u'] = {0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x00},
    ['v'] = {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00},
    ['w'] = {0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00},
    ['x'] = {0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x00},
    ['y'] = {0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x3C},
    ['z'] = {0x00,0x00,0x7E,0x0C,0x18,0x30,0x7E,0x00},
};

/* Override weak symbols from rust_driver_stubs.c */
uint32_t *gpu_setup_framebuffer(void) {
    /* Check if bootloader successfully set VESA mode */
    if (vbe_info->framebuffer != 0 && vbe_info->width >= 640 && vbe_info->height >= 480) {
        vbe_active = true;
        
        c_puts("[VBE] Mode: ");
        /* Print width */
        int w = vbe_info->width;
        if (w >= 1000) c_putc('0' + (w / 1000) % 10);
        if (w >= 100) c_putc('0' + (w / 100) % 10);
        c_putc('0' + (w / 10) % 10);
        c_putc('0' + w % 10);
        c_putc('x');
        /* Print height */
        int h = vbe_info->height;
        if (h >= 1000) c_putc('0' + (h / 1000) % 10);
        if (h >= 100) c_putc('0' + (h / 100) % 10);
        c_putc('0' + (h / 10) % 10);
        c_putc('0' + h % 10);
        c_putc('x');
        c_putc('0' + (vbe_info->bpp / 10) % 10);
        c_putc('0' + vbe_info->bpp % 10);
        c_puts(" LFB\n");
        
        /* Allocate backbuffer for double buffering */
        backbuffer_size = vbe_info->width * vbe_info->height * 4;
        backbuffer = (uint32_t*)kmalloc(backbuffer_size);
        
        if (backbuffer) {
            c_puts("[VBE] Double buffering enabled\n");
        } else {
            c_puts("[VBE] Warning: No backbuffer, drawing direct\n");
            backbuffer = (uint32_t*)vbe_info->framebuffer;
        }
        
        return backbuffer;
    }
    
    /* Fallback to VGA 320x200 */
    c_puts("[VBE] Fallback to VGA 320x200\n");
    vbe_active = false;
    set_mode_13h();
    setup_palette();
    
    /* VGA memory is at 0xA0000 */
    return (uint32_t*)0xA0000;
}

/* Wait for vertical retrace for vsync */
static void wait_vsync(void) {
    /* Wait for end of current retrace */
    while (io_inb(0x3DA) & 0x08);
    /* Wait for start of next retrace */
    while (!(io_inb(0x3DA) & 0x08));
}

int gpu_flush(void) {
    if (!vbe_active) {
        /* VGA mode - direct rendering, no flush needed */
        return 0;
    }
    
    if (backbuffer && backbuffer != (uint32_t*)vbe_info->framebuffer) {
        /* Wait for vsync to prevent tearing */
        wait_vsync();
        
        /* Copy backbuffer to framebuffer - optimized with 32-bit copies */
        uint32_t *fb = (uint32_t*)vbe_info->framebuffer;
        uint32_t count = vbe_info->width * vbe_info->height;
        
        /* Use rep movsd for fastest copy */
        __asm__ volatile (
            "cld\n\t"
            "rep movsl"
            : "+S"(backbuffer), "+D"(fb), "+c"(count)
            :
            : "memory"
        );
        
        /* Reset pointers after copy (movsl advances them) */
        /* Not needed since we don't use them after */
    }
    
    return 0;
}

int gpu_get_width(void) {
    if (vbe_active) return vbe_info->width;
    return 320;
}

int gpu_get_height(void) {
    if (vbe_active) return vbe_info->height;
    return 200;
}

/* Get drawing target - either backbuffer or direct framebuffer */
static uint32_t *get_draw_target(void) {
    if (vbe_active && backbuffer) {
        return backbuffer;
    }
    if (vbe_active) {
        return (uint32_t*)vbe_info->framebuffer;
    }
    return NULL;  /* VGA mode uses 8-bit */
}

/* Graphics primitives for VBE (32-bit color) */
void vbe_clear(uint32_t color) {
    if (!vbe_active) {
        /* VGA Clear */
        uint8_t c = (uint8_t)color;
        uint8_t *vga = (uint8_t*)0xA0000;
        for (int i = 0; i < 320*200; i++) vga[i] = c;
        return;
    }
    
    uint32_t *target = get_draw_target();
    uint32_t count = vbe_info->width * vbe_info->height;
    
    /* Fast fill using rep stosd */
    __asm__ volatile (
        "cld\n\t"
        "rep stosl"
        : "+D"(target), "+c"(count)
        : "a"(color)
        : "memory"
    );
}

void vbe_draw_pixel(int x, int y, uint32_t color) {
    if (!vbe_active) {
        if (x >= 0 && x < 320 && y >= 0 && y < 200) {
            ((uint8_t*)0xA0000)[y * 320 + x] = (uint8_t)color;
        }
        return;
    }
    
    if (x < 0 || y < 0 || x >= vbe_info->width || y >= vbe_info->height) return;
    
    uint32_t *target = get_draw_target();
    target[y * vbe_info->width + x] = color;
}

void vbe_fill_rect(int x, int y, int w, int h, uint32_t color) {
    if (!vbe_active) {
        /* VGA fallback */
        for (int py = y; py < y + h; py++) {
            for (int px = x; px < x + w; px++) {
                vbe_draw_pixel(px, py, color);
            }
        }
        return;
    }
    
    /* Clamp to screen bounds */
    int x1 = x < 0 ? 0 : x;
    int y1 = y < 0 ? 0 : y;
    int x2 = (x + w) > vbe_info->width ? vbe_info->width : (x + w);
    int y2 = (y + h) > vbe_info->height ? vbe_info->height : (y + h);
    
    if (x1 >= x2 || y1 >= y2) return;
    
    uint32_t *target = get_draw_target();
    uint32_t stride = vbe_info->width;
    int rect_width = x2 - x1;
    
    for (int py = y1; py < y2; py++) {
        uint32_t *line = target + (py * stride) + x1;
        /* Use rep stosd for each line */
        int cnt = rect_width;
        __asm__ volatile (
            "cld\n\t"
            "rep stosl"
            : "+D"(line), "+c"(cnt)
            : "a"(color)
            : "memory"
        );
    }
}

/* VBE character drawing */
void vbe_draw_char(int x, int y, uint8_t c, uint32_t fg, uint32_t bg) {
    if (c > 127) c = '?';
    
    if (!vbe_active) {
        /* VGA mode - use external vga_draw_char */
        extern void vga_draw_char(int, int, uint8_t, uint32_t, uint32_t);
        vga_draw_char(x, y, c, fg, bg);
        return;
    }
    
    uint32_t *target = get_draw_target();
    uint32_t stride = vbe_info->width;
    const uint8_t *glyph = vbe_font8x8[c];
    
    for (int row = 0; row < 8; row++) {
        int py = y + row;
        if (py < 0 || py >= vbe_info->height) continue;
        
        for (int col = 0; col < 8; col++) {
            int px = x + col;
            if (px < 0 || px >= vbe_info->width) continue;
            
            uint32_t color = (glyph[row] & (0x80 >> col)) ? fg : bg;
            target[py * stride + px] = color;
        }
    }
}

void vbe_draw_string(int x, int y, const uint8_t *str, uint32_t fg, uint32_t bg) {
    if (!str) return;
    int cx = x;
    while (*str) {
        vbe_draw_char(cx, y, *str, fg, bg);
        cx += 8;
        str++;
    }
}

/* Strong GPU function definitions that override weak symbols */
void gpu_clear(uint32_t color) {
    vbe_clear(color);
}

void gpu_draw_pixel(int x, int y, uint32_t color) {
    vbe_draw_pixel(x, y, color);
}

void gpu_fill_rect(int x, int y, int w, int h, uint32_t color) {
    vbe_fill_rect(x, y, w, h, color);
}

void gpu_draw_char(int x, int y, uint8_t c, uint32_t fg, uint32_t bg) {
    vbe_draw_char(x, y, c, fg, bg);
}

void gpu_draw_string(int x, int y, const uint8_t *str, uint32_t fg, uint32_t bg) {
    vbe_draw_string(x, y, str, fg, bg);
}
